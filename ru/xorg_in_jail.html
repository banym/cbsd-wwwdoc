<!--# include file="_start.html" -->
<!--# include file="currentver.html" -->
<h1><span>FreeBSD: Xorg in&nbsp;jail</span></h1>
<h2><a name="intro"><span>Введение</span></a></h2>
	<div class="block">
		<p>Традиционно принято считать, что FreeBSD&nbsp;&mdash; неплохой выбор в&nbsp;качестве серверной&nbsp;ОС, но&nbsp;на&nbsp;роль в&nbsp;качестве современной рабочей станции годится слабо. Апологеты и&nbsp;просто горячие головы с&nbsp;обеих сторон этого мнения приводят разные доводы за&nbsp;и&nbsp;против и&nbsp;данная статья не&nbsp;посвящена этому бесконечному спору. Вместо этого, здесь будет произведена попытка связать и&nbsp;пофантазировать вокруг, казалось&nbsp;бы, совершенно разных технологий, таких как Xorg и&nbsp;Jail, а&nbsp;также продемонстрирован один из&nbsp;сценариев работы с&nbsp;FreeBSD в&nbsp;качестве рабочей станции.</p>
		<p>Не&nbsp;так уж&nbsp;и&nbsp;редко на&nbsp;просторах интернета можно встретить информацию о&nbsp;том, какие дополнительные свойства от&nbsp;*nix системы приобретает пользователь, запускающий Xorg-based приложение в&nbsp;<a href="http://www.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8" target="_blank"><strong>chroot(8)</strong></a>.</p>
		<p>На&nbsp;это может быть множество причин, одна из&nbsp;них&nbsp;&mdash; вы&nbsp;любите эксперементировать с&nbsp;разным количеством окружений и&nbsp;при этом не&nbsp;очень хочется превращать файловую систему в&nbsp;помойку (и&nbsp;возможно, получать конфликты между тем или иным приложением по&nbsp;файловой системе.)</p>
		<p>Также, не&nbsp;последнюю роль играет безопасность. Никто не&nbsp;даст гарантии, что любой установленный софт, будь&nbsp;то <strong>skype</strong>, <strong>mc</strong>, <strong>screen</strong>, <strong>firefox</strong> и&nbsp;тд, при первом&nbsp;же обновлении, из-за досадной опечатки в&nbsp;коде не&nbsp;просканируют случайным образом ваш домашний каталог на&nbsp;предмет <strong>id_rsa</strong> ключей и&nbsp;<strong>known_hosts</strong>, <strong>.mysql_history, .bash_history</strong> и&nbsp;все ваши настройки эккаунтов из <em>~/.local</em>, <em>~/.config</em> , <em>~/.kde4</em> и&nbsp;не&nbsp;отправит их&nbsp;на&nbsp;сайт разработчика в&nbsp;качестве необходимой для дальнейшего развития обновленного софта статистики. Таким образом, chroot позволяет в&nbsp;этом случае не&nbsp;держать ваши яйца в&nbsp;одной корзине, что само по&nbsp;себе&nbsp;&mdash; прекрасно.</p>
		<p>Если <strong>chroot</strong> с&nbsp;этим справляется, может возникнуть вопрос&nbsp;&mdash; &laquo;а&nbsp;что может дать jail при запуске в&nbsp;нем Xorg&raquo;. Скорее всего, если знаете о&nbsp;различиях между jail и&nbsp;chroot и&nbsp;поскольку вы&nbsp;уже читаете эту статью, ответ уже найден и&nbsp;можно перейти к&nbsp;следующей главе. Если&nbsp;же нет, то:</p>
		<p>Основное различие в&nbsp;этом плане jail от&nbsp;chroot, это группирование процессов по&nbsp;ID (<strong>jid</strong>), который может учавствовать в&nbsp;определенных действиях как: вести аудит только за&nbsp;этими процессами, возможность собирать статистику через RACCT, установка лимитов через <a href="http://www.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8" target="_blank"><strong>rctl(8)</strong></a> (полезно для профилирования приложения). И, конечно&nbsp;же, привязка сетевых адресов, возможность изолированного стека и&nbsp;отдельной таблицы маршрутизации на&nbsp;все jailed процессы.</p>
		<p>Остальные дополнительные плюсы могут уже предоставить конкретные jail management утилиты. Таким образом, то&nbsp;что можно получить от&nbsp;X-jail, зависит только от&nbsp;ваших знаний и&nbsp;фантазии, а&nbsp;<strong>FreeBSD</strong> как обычно, выступает лишь инструментом для решения поставленной задачи.</p>
		
		<p>Приведу собственные частные случаи, что получает и&nbsp;использует автор.</p>
		<p>В&nbsp;случае с&nbsp;<strong>CBSD/jail/FreeBSD</strong>, появляется возможность:</p>
		<ul>
			<li>скачивать из&nbsp;репозитория преднастроенные окружения с&nbsp;различными вариантами популярных Windows Manager: <strong>KDE4, Fluxbox, Gnome3, LXDE</strong> и&nbsp;тд;</li>
			<li>удобная возможность экспорта и&nbsp;импорта в&nbsp;образ;</li>
			<li>репликация через <strong>zrep</strong> для инкрементальных бекапов;</li>
			<li>возможность применять файловые снапшоты;</li>
			<li>можно использовать <a href="http://www.freebsd.org/cgi/man.cgi?query=cpuset&amp;sektion=1" target="_blank"><strong>cpuset(1)</strong></a> для привязки всех&nbsp;X приложений на&nbsp;конкретное ядро или группу ядер;</li>
			<li>можно использовать различные лимиты на&nbsp;всю клетку, тогда как при chroot, вы&nbsp;можете применять лимиты через <a href="http://www.freebsd.org/cgi/man.cgi?query=limit&amp;sektion=1" target="_blank"><strong>limit(1)</strong></a> лишь на&nbsp;пользователя или PID, что не&nbsp;так удобно.</li>
			<li>В&nbsp;случае chroot и&nbsp;при наличие нескольких&nbsp;IP alias-ов в&nbsp;системе, в&nbsp;качестве source ip&nbsp;при установке соединения, приложение будет всегда использовать первый IP. В&nbsp;случае с&nbsp;jail и&nbsp;при наличие нескольких&nbsp;IP, вы&nbsp;можете ограничить&nbsp;IP для приложений лишь теми, которые вам нужны. При этом вы&nbsp;можете использовать <strong>PF/IPFW</strong> для подсчета трафика X-приложений, эмулировать &laquo;плохую&raquo; сеть, добавив задержки или потери на&nbsp;сеть этого jail, играясь с&nbsp;traffic bandwith и&nbsp;тд&nbsp;для изучения работы того или иного приложения в&nbsp;разных условиях.</li>
			<li>Если у&nbsp;вас есть несколько рабочих станций, с&nbsp;помощью jail вы&nbsp;можете устроить &laquo;плавающее&raquo; окружение более простым образом: за&nbsp;какой станцией вы&nbsp;бы не&nbsp;находились, вы&nbsp;всегда находитесь в&nbsp;одном окружении, вся history, вся принятая почта, даже если она была принята при работе на&nbsp;другой станции&nbsp;&mdash; всегда с&nbsp;вами. Вам не&nbsp;нужно обновлять софт сразу в&nbsp;3&nbsp;системах, если вы&nbsp;испольуете 3&nbsp;рабочих системы и&nbsp;набор&nbsp;ПО не&nbsp;меняется.</li>
		</ul>
		
	</div>
	<h2><a name="intro"><span>Что необходимо для X-jail</span></a></h2>
	<div class="block">
		<p>Для того, чтобы Xorg успешно работал в&nbsp;jail, необходимо снять ограничения jailed процессов на&nbsp;доступ к&nbsp;<em>/dev/io</em> и&nbsp;<em>/dev/kmem</em> устройствам. Уже <a href="http://www.leidinger.net/blog/2007/04/07/a-desktop-environment-in-a-jail/" target="_blank">долгое время</a> существуют патчи от&nbsp;Alexander Leidinger aka <a href="http://www.leidinger.net/" target="_blank">netchild</a>, которые предоставляют опциональность этих настроек. И&nbsp;сейчас, насколько мне известно, Jammie Gritton <a href="http://lists.freebsd.org/pipermail/svn-src-head/2014-January/055578.html" target="_blank">дал толчек к&nbsp;обсуждению</a> о&nbsp;возможном включении патчей в&nbsp;том или ином виде в&nbsp;базу. Вы&nbsp;можете применить патчи самостоятельно и&nbsp;пересобрать ядро, либо можете воспользоваться командой:</p>
	
		<pre class="brush:bash;ruler:true;">
			% cbsd repo action=get sources=kernel
		</pre>
		<p>И&nbsp;получить ядро с&nbsp;примененными патчами из&nbsp;репозитория <strong>CBSD</strong>.</p>
		<div class="warning">
			<p><strong>Внимание:</strong> Ввиду ограничений в&nbsp;ресурсах, данный патч применен только для ядра FreeBSD 11&nbsp;aka HEAD (на&nbsp;момент написания статьи) в&nbsp;репозитории <strong>CBSD</strong></p>
		</div>
		<p>При наличие этих патчей, в&nbsp;конфигурации <strong>CBSD</strong> jail появится опция <strong>allow_kmem</strong>, которую можно установить через <strong>cbsd jset</strong> или <strong>cbsd jconfig</strong></p>
		<p>Кроме того, вам может понадобится дописать отдельное правило для <a href="http://www.freebsd.org/cgi/man.cgi?query=devfs.ruleset&amp;sektion=5" target="_blank"><strong>devfs.ruleset(5)</strong></a>, чтобы соответствующие устройства стали видимы в&nbsp;<em>/dev</em> каталоге jail. Например такого содержания:</p>
		<pre class="brush:bash;ruler:true;">
			[devfsrules_unhide_xorg=8]
			add include $devfsrules_hide_all
			add include $devfsrules_unhide_basic
			add include $devfsrules_unhide_login
			add path agpgart unhide
			add path console unhide
			add path consolectl unhide
			add path dri unhide
			add path 'dri/*' unhide
			add path io unhide
			add path 'nvidia*' unhide
			add path sysmouse unhide
			add path mem unhide
			add path pci unhide
			add path tty unhide
			add path ttyv0 unhide
			add path ttyv1 unhide
			add path ttyv8 unhide
		</pre>
		<p>и&nbsp;указать соответствующий номер <strong>8</strong>&nbsp;в параметре <strong>devfs_ruleset</strong> из&nbsp;настройки jail.</p>
		<p>На&nbsp;этом настройка закончена и&nbsp;дальнейшая работа по&nbsp;запуску Xorg в&nbsp;jail ничем не&nbsp;отличается от&nbsp;обычных шагов:</p>
		<ul>
			<li>Установка ПО</li>
			<li>Генерация <em>/etc/X11/xorg.conf</em> (если необходимо) и&nbsp;создание <em>~/.xinitrc</em>
			<li>Запуск X</li>
		</ul>
		<a href="http://youtu.be/YcfmRnxHRKY" target="_blank">Короткое демо по запуску XJail с нуля</a>.
	</div>
	<h2><a name="intro"><span>Практический кейс: desktop everywhere</span></a></h2>
	<div class="block">
			<p>Хочется сделать небольшое отстутпление от темы и пофантазировать на тему будущих рабочих окружений и в частности, о моих ожиданиях по услугах хостинг-компаний ;-)</p>
			<p>Аналитики давно отмечают, что продажи обычных стационарных компьютеров падают и наступила эра мобильности и идея о том, что ПК должен быть на каждом рабочем месте и в каждом доме теперь не кажется такой уж гениальной.</p>
			<p>При этом, цены на аренду серверных мощностей в быстрых и надежных датацентрах неуклонно снижаются. Недавно автор статьи задумывался об апгрейде своей рабочей станции, от которой нужно лишь то, что делают классические офисные сотрудники:</p>
				<ul>
					<li>просмотр фильмов ;)</li>
					<li>офисные приложения: libreoffice, vim, kmail, gimp, yed, kdevelop, valgrind и прочий стандартный набор обычных домохозяек</li>
					<li>интернет броузер</li>
				</ul>
			<p>При подсчете выяснилось, что цена приорбетения нового системного блока удовлетворяющего этим потребностям равна цене аренды на 3-4 года сервера в датацентре с гораздо более мощными ресурсами, что конечно, породило мысль сделать рабочую систему в Датацентре, а через RDP/VNC подключатся к рабочему столу за приложениями, не требующими большой видеонагрузки, на что сгодится любой современный аналог Raspberry PI.</p>
			<p>При этом не учитывались плюсы от отсутствие шума в квартире, экономии на  электричестве и то, что сервер в датацентре доступен 24x7x365 дней, на котором параллельно можно развернуть пару jail с вспомогательными сервисами.</p>
			<p>К слову сказать, идее терминалов не один десяток лет и внутри интранет многх компаний она давно и с успехом воплощена. Но с ростом скоростей в интернете, уменьшением latency, вопрос подобных услуг от хостинг-компаний - дело времени. Впрочем, непонятно, что мешает этим заниматься компаниям предоставляющим последнюю милю до клиента. Пока что, автор знает лишь небольшой список компаний, которые подобным образом обеспечивают услугу <a href="http://en.wikipedia.org/wiki/Desktop_virtualization" target="_blank"><strong>VDI</strong></a> на выделенных каналах.</p>
			<p>Так или иначе, если идея выноса рабочего окружения в облако еще нежизнеспособна, то сделать какой-то гибрид на пути к этой идее можно попробовать сейчас.</p>
			<p>К примеру, у автора статьи есть рабочий домашний компьютер с одним монитором и NVidia картой. Также, есть ноутбук с Intel HD 3000. И есть рабочий компьютер в офисе, также на NVidia карте, но с двумя мониторами. Кроме того, есть RaspberryPI. ОС на всех системах - FreeBSD 10/11.</p>
			<p>Наша задача - получить плавающее Desktop-окружение на всех системах.</p>
			<p>Если при конфигурации всего двух систем достаточно лишь при остановке <strong>jail</strong> автоматически инициировать rsync или zrep на партнера, то с множественными системами понадобится какой-то централизованный сервер: например, можно заказать недорогой и всегда доступный VPS. Назовем его <strong>сервер снапшотов</strong>.</p>
			<p>Далее, создается Xjail с нашим обычным окружением (например <strong>KDE4, libreoffice, audacious, xbmc, chrome, firefox</strong> и тд.) с вашей учетной записью, после чего остается решить 2 задачи:</p>
			<ul>
				<li>Обеспечить синхронизацию данных между всеми системами</li>
				<li>Учесть разницу в периферии между теми системами, на которых вы пранируете запускать jail</li>
			</ul>
			<p>Первый пункт можно решить несколькими способами.
			Идеально, если все системы имеют файловую систему ZFS, которая позволяет не делая никаких паразитных нагрузок по сканированию модификаций как <strong>csync2</strong> или <strong>rsync</strong> выполнять zfs send и получать некий TimeMachine сервис,
			когда можно вернуться на любой из снапшотов. Ради интереса, усложним пример и договоримся, что наши клиенты на файловой системе отличны от ZFS, но при этом функции TimeMachine очень хочется оставить. В этом случае, ZFS ставим только на сервер снапшотов.
			Для приема и отправки данных будем использовать rsync, где каждая сессия будет порождать создание ZFS snapshot на сервере снапшотов. Для этого, помещаем в <strong>rsyncd.conf</strong> следующую строчку:</p>
			<pre class="brush:bash;ruler:true;">
			...
			pre-xfer exec = /root/bin/netsnap_rotate zroot/xjail1
			...
			</pre>
			<p>Где - zroot - общий пул, xjail1 - dataset для клетки с имемем <strong>xjail1</strong>, которая и будет нашим окружением. Скрипт <em>/root/bin/netsnap_rotate</em> будет создавать при каждом вызове новый снапшот. Кроме этого, чтобы количество снапшотов не было бесконечным, этот скрипт будет заниматься ротацией снапшотов, удаляя устаревшие. Тогда, скрипт <em>/root/bin/netsnap_rotate</em> может выглядеть так:</p>
			<pre class="brush:bash;ruler:true;">
				#!/bin/sh
				set -e
				IFS="   "
				OLDESTDT=`date +%s`
				OLDESTSNAP="NOP"

				# cmp for oldest timestamp
				oldest()
				{
					if [ $2 -lt $OLDESTDT ]; then
						OLDESTDT=$2
						OLDESTSNAP=$1
					fi
				}
				
				if [ -z "$1" ]; then {
					echo "Empty FS"
					exit 1
				}
				
				OLDESTSNAP=$(zfs list -H -r -t snapshot -o name,creation $1 2>/dev/null|while read snap time; do
							dtstamp=`date -j -f "%a %b %d %H:%M %Y" "${time}" "+%s"`
							oldest $snap $dtstamp
							echo "$OLDESTSNAP"
						done)
				
				LAST=`echo $OLDESTSNAP|tail -n1`
				[ "${LAST}" = "NOP" -o -z "${OLDESTSNAP}" ] && exit
				# echo "re-created snapshot: $LAST on `date`" |mail -s "Snapshot rotated" operator@my.domain
				zfs destroy ${LAST}                                                                                                                                                                                                                                                            
				zfs snapshot ${LAST}
			</pre>
			<p>, где <strong>OLDESTSNAP</strong> устанавливаем в то количество снапшотов, которое хотим хранить</p>
			<li><img src="/img/floatdesktop1.png" alt="" /></li>
			<p>Вторая задача по учету разницы конфигураций, решается еще проще. При первом запуске X -configure на каждой из систем, сохраняем xorg.conf за пределами jail, например в <em>$workdir/jails-system/xjail1/hostname_xorg.conf</em>, а в настройках клетки и параметре <strong>exec_master_prestart</strong>, которая отрабатывает в мастер хосте перед запуском клетки, просто копируем нужную конфигу в <em>/etc/X11/xorg.conf</em> клетки. Таким образом, как бы не отличались хост-машины графическими драйверами, настройками и количеством мониторов, система всегда будет запускаться с правильными и оптимальными настройками. Некоторые WM могут запоминают геометрию окон при последнем запуске и восстанавливать на прежнем месте. Если это является проблемой, таким же образом достаточно найти файлы, отвечающие за этот кеш и копировать их таким же образом, но как правило, все WM имеют на этот счет возможность выключить эту особенность.</p>
			<p>Кроме этого, на VPS/сервере снапшотов мы можем запустить VNC/NX/RDP сервер для соединений, когда большой видоепоток нам не нужен. Это позволит нам соединиться в наш рабочий стол с любых отличных от FreeBSD систем, а также пользоваться тонким клиентом с ARM Embedded устройств, которые сейчас есть в каждом пылесосе и на которых, традиционно, Linux/FreeBSD/Android работают вполне сносно</p>
			<p>Также, нам останется в <strong>exec_master_poststop</strong> вписать команду, которая запустит rsync для отправки данных на сервер, а в <strong>exec_master_prestart</strong> - запускает rsync для их получения. Другими словами, когда вы завершаете работу с jail, все модификации отправляются на сервер, при запуске - принимаются с него. В случае с ZFS, крайне удобно ставить zfs send в crontab, чтобы она отправляла модификации и при активном jail, тогда финальная сихронизация при остановке jail займет пару секунд.  В случае с rsync/csync2 это делать не очень желательно, ввиду паразитной I/O нагрузки при сканировании модификаций.</p>
			<p>Также, если у вас есть какие-то объемные данные, которые должны быть доступны в клетке при работе на одной из WKS, но совершенно не нужны (ввиду объемов) или даже нежелательны при работе на других, удобно использовать fstab.local, через которую при запуске клетки на хосте X будет примонтированы вспомогательные данные из мастер-хоста. Например, на домашней машине есть склад media-материалов (видеролики, mp3 музыка, образы виртуальных машин VirtualBox), которые совершенно не хочется реплицировать и иметь на WKS в офисе. Поэтому, файл <em>$workdir/jails-fstab/xjail1.fstab.local</em> на домашней машине имеет запись:
			<pre class="brush:bash;ruler:true;">
				/usr/media /usr/media nullfs rw 0 0
			</pre>
			<p>которая монтирует всю информацию в Jail, однако в ZFS репликации не учавствует, поскольку это отдельный dataset (для rsync достаточно добавить --exclude)</p>
			<p>Подводя итоги: с помощью небольших телодвижений по связке FreeBSD, ZFS, zrep (или rsync), cbsd и Xjail мы получаем плавающее рабочее окружение, не страдающее от разницы периферии разных станций и не требующая постоянное ручное переконфигурирование, получаем резервное копирование в виде избыточности копий на N системах и защиту от <strong>rm -rf /</strong> и TimeMachine сервис как бонус в виде ZFS snapshot. При этом окружение доступно по VNC, однако ввиду неготовности сегодняшних каналов обеспечивать качественную связь в современных реалиях, предполагаем что при 99% времени всей работы, задействована именно локальная графическая/media подсистема.</p>
			<p>BTW: по подобной схеме, вместо JAIL может быть запущена любая система через гипервизор, например Linux окружение в bhyve или Windows в VirtualBox, но с образом на ZFS, которая предоставит возможность снапшотов для файловых систем которые о них и не знают, но это тема уже другой статьи, не связанной с Xorg-in-jail</p>
	</div>
<!--# include file="_end.html" -->