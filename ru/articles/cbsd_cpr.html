<!--# include file="/ru/_start.html" -->
	<h1><span>Сборка своих репозиториев ПО для FreeBSD через cbsd cpr</span></h1>
	
	<h2><a name="main_info">Общая информация</a></h2>
	<div class="block">
		<!-- Тэги: <strong>howto</strong> -->
		<p>//Draft, unformatted</p>
		<p>Одна из бесконечных задач системных инженеров заключается в работе по установке и поддержанию в актуальном состоянии программного обеспечения серверов и рабочих станций.</p>
		
		<p>Также, в целях безопасности и надежности, желательно иметь сборки на своих ресурсах, а не публичных серверах. Даже официальные репозитории подвержены различным инцидентам и взломам, в результате которых вы можете оказаться в ситуации, когда ПО срочно нужно, а репозиторий который вы не контроллируете — недоступен.</p>
		
		<p>Помимо этого, сам процесс обновления должен подразумевать возможность отката на предыдущее состояние, если по каким-то причинам новые версии работают некорректно.</p>
		
		<p>Хорошо, когда для решения этой задачи используется резервное копирование или, что гораздо практичнее, использовать снэпшот файловой системы: например, перед работами сделать <strong>ZFS snapshot</strong> для клетки, и при любых проблемах после обновления в течении секунды вернуть состояние обратно.</p>
		
		<p>Однако, занимаясь работой по построению инфраструктуры для собственного репозитория, вы можете заложить возможность версионности на уровне репозитория, что при комбинировании с подстраховкой на клиенте сводит риск попасть в неблагоприятное положение на нет.</p>
		
		<p>Когда я начинал писать <strong>cbsd cpr</strong>, уже давно были известны аналогичные функционалы в виде <strong>TinderBox</strong> и <strong>Poudriere</strong>, однако в каждом из
		этих решений мне чего-то не хватало.</p>
		
		<p>Требования, которые предьявляла моя задача:</p>
		
		<ul>
			<li>Сборка производится по заранее сгенерированныму списку ПО.</li>
			<li>Сборка каждого отдельного репозитория/версии производится в изолированном окружении (включая собственный кеш <strong>ccache</strong> (опционально) для компиляции, который накапливается при каждых повторных сборках в пределах версии и ветки);</li>
			<li>При сборке окружения, используется база и ядро, используемые cbsd, соответственно, при необходимости иметь более свежую версию базы или ядра, можно воспользоваться <strong>cbsd repo</strong> для получения объектов из репозитория, или <strong>cbsd csup/buildworld/kernel*</strong> для сборки с нуля.</li>
			<li>Каждый набор ПО (или один и тот же список) может использовать свою собственную <strong>версию опций портов</strong> (/var/db/ports) и персональный <strong>make.conf</strong> файл и иметь именованный репозиторий, например в таком виде:
				<ul>
					<li><strong>nox</strong> — WITHOUT_X11, набор ПО для серверного окружения, без поддержки X — этот набор ПО используется на production-серверах.</li>
					<li><strong>devnox</strong> — тот же набор ПО и опция WITHOUT_X11, но софт собран с дебагом и поддержкой DTRACE; этот набор ПО используется на dev-клетках, где идет разработка и профилирование проектов.</li>
					<li><strong>xorg</strong> — X11-based GUI приложения. Данный набор содержит xorg, kde, gnome, мультимедия, офисные приложения, IDE для разработки и прочий инструментарий, характерный для рабочих станций.</li>
				</ul>
			<li>Иметь возможность использовать больше одного билдера ПО, в этом случае сценарии репозитория и опции портов реплицировалась (например через csync2) на соответствующие билдеры: если в процессе сборки репозитория <strong>nox</strong> вы выбрали некоторые опции для одного порта, то собирая тот же репозиторий <strong>nox</strong> на другом сервере или другой версии, вывода окна со списом опций уже не будет — он синхронизируется с сервера, которая прошла этот путь первой.</li>
			<li>Иметь возможность задействовать для компиляции свободные ресурсы серверов через distcc. В этом случае, на нужных серверах скачивалась и запускалась клетка <strong>distcc</strong> с минимальным <strong>nice</strong>, что при сборке не мешало работать остальным сервисам.</li>
			<li>Иметь версионность каталогов, куда сохраняются новые сборки. В один момент времени только один сет является активным, переключение происходит сменой симлинка. Кроме этого, при наличии нескольких <strong>download</strong> серверов, требуется время для полной синхронизации, поэтому проливка осуществляется в неактивную (slave) зону и по факту полной сихронизации, одномоментно переключается.
			<li>Конечные хосты забирают готовые пекеджи не с билдеров, а с соответствующих <strong>downloads</strong>-серверов, которых может быть несколько. Таким образом, сервера отдающие пекеджи, не зависят от здоровья самих билдеров.
			<pre>
	Протоколирование работы скрипта ведется в /tmp каталоге chroot окружения:
	— build.log — общий лог процесса сборки
	— packages.log — лог на этапе pkg create
	— port_log* — временные файлы лога компиляции индивидуального порта, удаляющиеся автоматически при успешной сборке порта
			</pre>
			</li>
			<li>Каждая версия репозитория может иметь свой собственный E-mail для уведомлений о начале-конце сборки.
			<br><br>
			<li>Каждую сборку можно запустить с параметром <strong>pause=1</strong>, что по окончанию сборки система будет ожидать нажатия клавиши. А пока это не сделано — можно зайти в chroot окружение, просмотреть проблемы и исправить их вручную.
			<br>
			<br><li>Каждый билдер может быть на своей <strong>Major</strong> веткии и архитектуры и специализироваться на сборках только для текущей Major ветки и архитектуры для минимизации <strong>cross-{build,version}</strong> проблем (cbsd cpr скрипт позволяет через ver=X.Y тем не менее собирать фиксированную версию)
			<br><br>
			<li>порты монтируются в chroot окружение из мастер системы, либо каждое окружение имеет свою копию портов.</li>
		</ul>
		
		<p><strong>Схематичный рисунок сборочной фермы:</strong></p>
		<p class="text-center"><img src="/img/bldfarm.png" alt="" /></p>
		
		<p>Для комфортной работы напишем переключатель версионности каталогов.</p>
		
		<p>Принцип работы данного скрипта простая. Допустим, у нас есть локация <strong>/home/web/pkg.bsdstore.ru/</strong> для хранения пекеджей, где:</p>
		
		<p><strong>/home/web/pkg.bsdstore.ru/master</strong> — это SymbolicLink на активный set с билдами. Этот же путь является Docroot для WEB сервера и его имя никогда не меняется.</p>
		
		<p><strong>/home/web/pkg.bsdstore.ru/1</strong> — первый физический каталог, содержащий один набор данных</p>
		<p><strong>/home/web/pkg.bsdstore.ru/2</strong> — второй физический каталог, содержащий предыдущую (или следующую) версию набора данных</p>
		<p>симлинк master будет указывать лишь на какой-то конкретный каталог, при каждом запуске скрипта указывая по кругу на следующий.</p>
		<pre class="brush:bash;ruler:true;">
		#!/bin/sh
		# When use with config file, follow variable must be set, sample:
		# _PATH="/usr/symlinks"
		# _RANGE="1 2 3"
		# _MASTER_LINK="master"
		# _SLAVE_LINK="slave"
		# _ACTION="next"
		# _X=1  #if action=set
		# _Y=2  #if action=set
		#
		# or by command line:
		# ./symlink_changer -p /usr/symlinks -r "1 2 3" -m master -s slave -a next
		#

		err() {
			exitval=$1
			shift
			echo "$*" 1>&2
			exit $exitval
		}

		get_symlink() {
			local _res

			[ -z $1 ] &amp;&amp; return 1
			_res=`readlink ${_PATH}/${1}`
			[ $? -ne 0 ] &amp;&amp; return 1
			printf `basename ${_res}`
		}

		get_next() {
			local _cur _test _first _count

			_test="${_PATH}/${1}"
			_cur=0
			_count=0

			for i in ${_RANGE}; do
				[ ${_count} -eq 0 ] &amp;&amp; _first=${i}  ## store first element
				[ ${_cur} -eq 1 ] &amp;&amp; printf ${i} &amp;&amp; return 0
				[ "${_PATH}/$i" = "${_test}" ] &amp;&amp; _cur=1
				_count=$(( _count + 1 ))
			done

			printf ${_first}
		}

		get_prev() {
			local _cur _test _first _count _REVSLOTS
			_test="${_PATH}/${1}"
			_cur=0
			_count=0
			_REVSLOTS=`echo ${_RANGE} | tr " " "\n" |sort -r`

			for i in ${_REVSLOTS}; do
				[ ${_count} -eq 0 ] &amp;&amp; _first=${i}  ## store first element
				[ ${_cur} -eq 1 ] &amp;&amp; printf ${i} &amp;&amp; return 0
				[ "${_PATH}/$i" = "${_test}" ] &amp;&amp; _cur=1
				_count=$(( _count + 1 ))
			done

			printf ${_first}
		}
		# create or change new layout by
		# $1 - new dir for master link
		# $2 - new dir for slave
		sym_action() {
			local _masterdir _slavedir
			[ -z "${1}" -o -z "${2}" ] &amp;&amp; return 1

			_masterdir="${_PATH}/${1}"
			_slavedir="${_PATH}/${2}"

			[ ! -d "${_masterdir}" ] &amp;&amp; mkdir "${_masterdir}"
			[ ! -d "${_slavedir}" ] &amp;&amp; mkdir "${_slavedir}"

			# ln -sf not work correctly here - create symlink in old master folder
			cd ${_PATH}
			rm -f "${_PATH}/${_MASTER_LINK}" &amp;&amp; /bin/ln -s "${1}" "${_MASTER_LINK}"
			rm -f "${_PATH}/${_SLAVE_LINK}" &amp;&amp; /bin/ln -s "${2}" "${_SLAVE_LINK}"
		}

		usage() {
			echo "$0 -c confpath -p path -r \"range\" -m masterlink_name -s slavelink_name -a action [-x dir1] [-y dir2]"
			echo "action must be: next, prev, set"
			echo "when action = set, x/y = is new masterdir/slavedir"
			exit
		}


		# MAIN()
		while getopts "c:p:r:m:s:a:x:y:" opt; do
				case "$opt" in
				c) _conf="$OPTARG" ;;
				p) _path="$OPTARG" ;;
				r) _range="$OPTARG" ;;
				m) _master_link="$OPTARG" ;;
				s) _slave_link="$OPTARG" ;;
				a) _action="$OPTARG" ;;
				x) _x="$OPTARG" ;;
				y) _y="$OPTARG" ;;
				*) usage ;;
				esac
				shift $(($OPTIND - 1))
		done

		[ -n "${_conf}" -a -f "${_conf}" ] &amp;&amp; . ${_conf}

		[ -n "${_path}" ] &amp;&amp; _PATH=${_path}
		[ -n "${_range}" ] &amp;&amp; _RANGE=${_range}
		[ -n "${_master_link}" ] &amp;&amp; _MASTER_LINK=${_master_link}
		[ -n "${_slave_link}" ] &amp;&amp; _SLAVE_LINK=${_slave_link}
		[ -n "${_action}" ] &amp;&amp; _ACTION=${_action}
		[ -n "${_x}" ] &amp;&amp; _X=${_x}
		[ -n "${_y}" ] &amp;&amp; _Y=${_y}

		[ -z "${_ACTION}" ] &amp;&amp; err 1 "Give me action"
		[ -z "${_PATH}" -o -z "${_MASTER_LINK}" -o -z "${_SLAVE_LINK}" -o -z "${_RANGE}" ] &amp;&amp; err 1 "not all neccesary variable has been set"
		cd ${_PATH} || err 1 "Cant cwd to ${_PATH}"

		# init area
		_curmaster=`eval get_symlink ${_MASTER_LINK}`
		_curslave=`eval get_symlink ${_SLAVE_LINK}`

		case "${_ACTION}" in
		"next")
				_master=`eval get_next ${_curmaster}`
				_slave=`eval get_next ${_master}`
				;;
		"prev")
				_master=`eval get_prev ${_curmaster}`
				_slave=${_curmaster}
				;;
		"set")
				_master="${_X}"
				_slave="${_Y}"
				;;
		*)
				err 1 "No action set"
				;;
		esac

		sym_action ${_master} ${_slave}
		</pre>

		<p>&hellip;</p>
		<p><strong>WIP</strong><em>(Work in progress)</em></p>
	</div>
<!--# include file="/ru/_end.html" -->